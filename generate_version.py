import json
import os
import sys

"""
Generates a `_version.py` file that exposes your `manifest.json` package version
as a Talon action (e.g., `actions.user.my_package_version()`). Also includes
automatic dependency validation on Talon startup, printing clear error messages
if dependencies are missing or outdated with installation/update instructions for
other packages that also have a `manifest.json` and `_version.py` generated by
this generator.

Usage: python generate_version.py <directory> [<directory2> ...] [--force]

Examples:
  python generate_version.py ../talon-package
  python generate_version.py ../package1 ../package2
"""

def get_generator_version() -> str:
    """Get the version of manifest_builder from its own manifest.json"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    manifest_path = os.path.join(script_dir, 'manifest.json')
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest = json.load(f)
            return manifest.get('version', '1.0.0')
    except:
        return '1.0.0'

def get_existing_generator_version(version_file_path: str) -> str | None:
    """Extract generator version from existing version.py file"""
    if not os.path.exists(version_file_path):
        return None

    try:
        with open(version_file_path, 'r', encoding='utf-8') as f:
            first_line = f.readline()
            # Look for: """Generated by talon-manifest-generator v1.2.0"""
            if 'talon-manifest-generator v' in first_line:
                version = first_line.split('v')[1].split('"')[0]
                return version.strip()
    except:
        pass
    return None

def add_version_action_to_manifest(manifest_path: str, action_name: str) -> None:
    version_action = f"user.{action_name}_version"
    with open(manifest_path, 'r', encoding='utf-8') as f:
        manifest = json.load(f)

    if 'contributes' not in manifest:
        manifest['contributes'] = {}
    if 'actions' not in manifest['contributes']:
        manifest['contributes']['actions'] = []

    if version_action not in manifest['contributes']['actions']:
        manifest['contributes']['actions'].append(version_action)
        manifest['contributes']['actions'].sort()

        with open(manifest_path, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2)

def generate_version_action(package_dir: str, force: bool = False) -> None:
    """Generate version action file for a package"""
    full_package_dir = os.path.abspath(package_dir)

    if not os.path.isdir(full_package_dir):
        print(f"Error: Directory not found: {full_package_dir}")
        sys.exit(1)

    # Read manifest.json
    manifest_path = os.path.join(full_package_dir, 'manifest.json')
    if not os.path.exists(manifest_path):
        print(f"Error: manifest.json not found in {full_package_dir}")
        print("Run generate_manifest.py first to generate a manifest.")
        sys.exit(1)

    with open(manifest_path, 'r', encoding='utf-8') as f:
        manifest = json.load(f)

    namespace = manifest.get('namespace', '')
    requires_version_action = manifest.get('_generatorRequiresVersionAction', True)
    has_dependencies = bool(manifest.get('dependencies'))
    dependency_check = manifest.get('validateDependencies', True)

    if not requires_version_action and (not has_dependencies or not dependency_check):
        print(f"\nSkipping _version.py generation:")
        print(f"  _generatorRequiresVersionAction is false and no dependency validation needed")
        return

    # Only require namespace if version action is required
    if requires_version_action and not namespace:
        print(f"Error: No namespace found in manifest.json")
        print(f"Either add a namespace or set _generatorRequiresVersionAction to false")
        sys.exit(1)

    # Strip 'user.' prefix if present for function name
    if namespace and namespace.startswith('user.'):
        action_name = namespace[5:]
    elif namespace:
        action_name = namespace
    else:
        action_name = None

    package_name = manifest.get('name', os.path.basename(full_package_dir))
    generator_version = get_generator_version()

    # Check if file already exists and compare versions
    version_file_path = os.path.join(full_package_dir, '_version.py')
    version_file_exists = os.path.exists(version_file_path)
    existing_version = get_existing_generator_version(version_file_path)

    # Force regeneration if dependency state changed
    needs_regen = False
    if version_file_exists:
        with open(version_file_path, 'r', encoding='utf-8') as f:
            existing_content = f.read()
            has_validation_code = 'validate_dependencies' in existing_content
            if has_dependencies != has_validation_code:
                needs_regen = True
                print(f"Regenerating _version.py (dependency state changed)")

    if not force and not needs_regen and existing_version and existing_version == generator_version:
        print(f"\n_version.py is already up to date (v{generator_version})")
        print(f"Use --force to regenerate anyway")
        sys.exit(0)
    elif force and existing_version == generator_version:
        print(f"Force regenerating _version.py (v{generator_version})")
    elif existing_version:
        print(f"Updating _version.py from v{existing_version} to v{generator_version}")

    # Generate the version action file
    description_parts = []
    if action_name:
        description_parts.append(f"- Package version checking via {action_name}_version() action")
    if has_dependencies and dependency_check:
        description_parts.append("- Automatic dependency validation on startup")

    talon_imports = "Module, actions, app" if (has_dependencies and dependency_check) else "Module"

    version_file_content = f'''"""
DO NOT EDIT - Auto-generated file
Generated by talon-manifest-generator v{generator_version}

This file provides:
{chr(10).join(description_parts) if description_parts else "- Version metadata for the package"}
"""
import json
from pathlib import Path
from talon import {talon_imports}

'''

    # Only include version action if namespace is provided
    if action_name:
        version_file_content += f'''mod = Module()

try:
    # Version is cached at import. Restart or save this file to pick up changes.
    with open(Path(__file__).parent / 'manifest.json', 'r', encoding='utf-8') as f:
        _VERSION = tuple(map(int, json.load(f)['version'].split('.')))
except (FileNotFoundError, KeyError, ValueError) as e:
    print(f"ERROR: {package_name} failed to load version from manifest.json: {{e}}")
    _VERSION = (0, 0, 0)

@mod.action_class
class Actions:
    def {action_name}_version() -> tuple[int, int, int]:
        """
        Returns the package version as (major, minor, patch).

        Usage: actions.user.{action_name}_version() >= (1, 2, 0)
        """
        return _VERSION
'''

    if has_dependencies and dependency_check:
        version_file_content += f'''
def validate_dependencies():
    """
    Checks dependencies from manifest.json and calls {{namespace}}_version()
    for each to verify installed versions meet requirements on Talon startup.

    Prints warnings to Talon log when dependencies are missing or outdated,
    including installation/update instructions. Can be disabled by setting
    'validateDependencies': false in manifest.json.
    """
    try:
        with open(Path(__file__).parent / 'manifest.json', 'r') as f:
            data = json.load(f)

        if not data.get('validateDependencies', True):
            return

        deps = data.get('dependencies', {{}})
        errors = []

        for dep, info in deps.items():
            version_action = f"{{info.get('namespace')}}_version"
            github_url = info.get('github', '')
            version_str = info.get('min_version') or info.get('version')
            try:
                action_ref = actions
                for part in version_action.split('.'):
                    action_ref = getattr(action_ref, part)
                installed = action_ref()

                # Handle both tuple and string versions
                if isinstance(installed, str):
                    installed = tuple(int(x) for x in installed.split('.'))

                required = tuple(int(x) for x in version_str.split('.'))
                if installed < required:
                    installed_str = '.'.join(map(str, installed))
                    errors.append(f"  Update {{dep}} to {{version_str}}+ (currently {{installed_str}})")
                    if github_url:
                        errors.append(f"    Navigate to the {{dep}} directory and run: git pull")
                        errors.append(f"    {{github_url}}")
                    errors.append("")
            except Exception as e:
                errors.append(f"  Cannot verify {{dep}} {{version_str}}+ (missing or invalid {{version_action}} action)")
                if github_url:
                    errors.append(f"    Install/update from: {{github_url}}")
                errors.append(f"    {{e}}")
                errors.append("")

        if errors:
            print(f"{'='*60}")
            print(f"{{data.get('name')}}: dependency requirements not met.\\n")
            for error in errors:
                print(error)
            print("  WARNING: Review code from unfamiliar sources before installing")
            print("  Note: You may need to restart Talon after updating")
            print("  To disable these warnings:")
            print(f"    Set 'validateDependencies': false in {{data.get('name')}}/manifest.json")
            print(f"{'='*60}")
    except:
        pass

app.register("ready", validate_dependencies)
'''

    # Write the version file
    with open(version_file_path, 'w', encoding='utf-8') as f:
        f.write(version_file_content)

    if not version_file_exists and action_name:
        add_version_action_to_manifest(manifest_path, action_name)

    display_path = version_file_path.replace('\\', '/')
    print(f"\nGenerated: {display_path}")
    if action_name:
        print(f"  Action: actions.user.{action_name}_version()")
    print(f"  Generator: v{generator_version}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python generate_version.py <directory> [<directory2> ...] [--force]")
        print("Example: python generate_version.py ../my-package")
        print("Example: python generate_version.py ../package1 ../package2")
        sys.exit(1)

    force = '--force' in sys.argv
    package_dirs = [arg for arg in sys.argv[1:] if arg != '--force']

    for package_dir in package_dirs:
        generate_version_action(package_dir, force)
