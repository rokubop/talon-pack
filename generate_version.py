import json
import os
import sys

"""
Generates a `_version.py` file that exposes your `manifest.json` package version
as a Talon action (e.g., `actions.user.my_package_version()`). Also includes
automatic dependency validation on Talon startup, printing clear error messages
if dependencies are missing or outdated with installation/update instructions for
other packages that also have a `manifest.json` and `_version.py` generated by
this generator.

Usage: python generate_version.py <directory> [<directory2> ...] [--force]

Examples:
  python generate_version.py ../talon-package
  python generate_version.py ../package1 ../package2
"""

def get_generator_version() -> str:
    """Get the version of manifest_builder from its own manifest.json"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    manifest_path = os.path.join(script_dir, 'manifest.json')
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest = json.load(f)
            return manifest.get('version', '1.0.0')
    except:
        return '1.0.0'

def get_existing_generator_version(version_file_path: str) -> str | None:
    """Extract generator version from existing version.py file"""
    if not os.path.exists(version_file_path):
        return None

    try:
        with open(version_file_path, 'r', encoding='utf-8') as f:
            first_line = f.readline()
            # Look for: """Generated by talon-pack v1.2.0"""
            if 'talon-pack v' in first_line:
                version = first_line.split('v')[1].split('"')[0]
                return version.strip()
    except:
        pass
    return None

def add_version_action_to_manifest(manifest_path: str, action_name: str) -> None:
    version_action = f"user.{action_name}_version"
    with open(manifest_path, 'r', encoding='utf-8') as f:
        manifest = json.load(f)

    if 'contributes' not in manifest:
        manifest['contributes'] = {}
    if 'actions' not in manifest['contributes']:
        manifest['contributes']['actions'] = []

    if version_action not in manifest['contributes']['actions']:
        manifest['contributes']['actions'].append(version_action)
        manifest['contributes']['actions'].sort()

        with open(manifest_path, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2)

def generate_version_action(package_dir: str, force: bool = False, dry_run: bool = False, verbose: bool = False, alt_manifest_path: str = None) -> None:
    """Generate version action file for a package"""
    full_package_dir = os.path.abspath(package_dir)

    if not os.path.isdir(full_package_dir):
        print(f"Error: Directory not found: {full_package_dir}")
        sys.exit(1)

    # Read manifest.json (or from alternate path if provided)
    manifest_path = alt_manifest_path or os.path.join(full_package_dir, 'manifest.json')
    if not os.path.exists(manifest_path):
        if dry_run:
            # In dry-run mode, manifest might not exist yet (would be created by generate_manifest)
            from diff_utils import DIM, RESET
            print(f"_version.py: {DIM}(skipped - manifest.json doesn't exist yet){RESET}")
            return
        else:
            from diff_utils import RED, RESET
            print(f"{RED}Error: manifest.json not found in {full_package_dir}{RESET}")
            print("Run generate_manifest.py first to generate a manifest.")
            sys.exit(1)

    with open(manifest_path, 'r', encoding='utf-8') as f:
        manifest = json.load(f)

    namespace = manifest.get('namespace', '')
    requires_version_action = manifest.get('_generatorRequiresVersionAction', True)
    has_dependencies = bool(manifest.get('dependencies'))
    dependency_check = manifest.get('validateDependencies', True)

    if not requires_version_action and (not has_dependencies or not dependency_check):
        from diff_utils import DIM, RESET
        if verbose:
            print(f"\nSkipping _version.py generation:")
            print(f"  _generatorRequiresVersionAction is false and no dependency validation needed")
        else:
            print(f"{DIM}_version.py: skipped{RESET}")
        return

    # Only require namespace if version action is required
    if requires_version_action and not namespace:
        from diff_utils import RED, RESET
        print(f"{RED}Error: No namespace found in manifest.json{RESET}")
        print(f"Either add a namespace or set _generatorRequiresVersionAction to false")
        sys.exit(1)

    # Strip 'user.' prefix if present for function name
    if namespace and namespace.startswith('user.'):
        action_name = namespace[5:]
    elif namespace:
        action_name = namespace
    else:
        action_name = None

    package_name = manifest.get('name', os.path.basename(full_package_dir))
    generator_version = get_generator_version()

    # Check if file already exists and compare versions
    version_file_path = os.path.join(full_package_dir, '_version.py')
    version_file_exists = os.path.exists(version_file_path)
    existing_version = get_existing_generator_version(version_file_path)

    # Force regeneration if dependency state changed
    needs_regen = False
    if version_file_exists:
        with open(version_file_path, 'r', encoding='utf-8') as f:
            existing_content = f.read()
            has_validation_code = 'validate_dependencies' in existing_content
            if has_dependencies != has_validation_code:
                needs_regen = True
                print(f"Regenerating _version.py (dependency state changed)")

    if not force and not needs_regen and existing_version and existing_version == generator_version:
        from diff_utils import status_no_change
        if verbose:
            print(f"\n_version.py is already up to date (v{generator_version})")
            print(f"Use --force to regenerate anyway")
        else:
            print(status_no_change("_version.py"))
        sys.exit(0)
    elif force and existing_version == generator_version:
        if verbose:
            print(f"Force regenerating _version.py (v{generator_version})")
    elif existing_version and verbose:
        print(f"Updating _version.py from v{existing_version} to v{generator_version}")

    # Generate the version action file
    description_parts = []
    if action_name:
        description_parts.append(f"- Package version checking via {action_name}_version() action")
    if has_dependencies and dependency_check:
        description_parts.append("- Automatic dependency validation on startup")

    talon_imports = "Module, actions, app" if (has_dependencies and dependency_check) else "Module"

    version_file_content = f'''"""
DO NOT EDIT - Auto-generated file
Generated by talon-pack v{generator_version}

This file provides:
{chr(10).join(description_parts) if description_parts else "- Version metadata for the package"}
"""
import json
from pathlib import Path
from talon import {talon_imports}

'''

    # Only include version action if namespace is provided
    if action_name:
        version_file_content += f'''mod = Module()

_cached_version = None

def _get_version() -> tuple[int, int, int]:
    """
    Loads version from manifest.json. Cached after first successful load.
    To reload: restart Talon or save this file
    """
    global _cached_version
    if _cached_version is not None:
        return _cached_version

    try:
        with open(Path(__file__).parent / 'manifest.json', 'r', encoding='utf-8') as f:
            version = tuple(map(int, json.load(f)['version'].split('.')))
            _cached_version = version
            return version
    except Exception as e:
        print(f"ERROR: {package_name} failed to load version from manifest.json: {{e}}")
        return (0, 0, 0)

@mod.action_class
class Actions:
    def {action_name}_version() -> tuple[int, int, int]:
        """
        Returns the package version as (major, minor, patch).

        Usage: actions.user.{action_name}_version() >= (1, 2, 0)
        """
        return _get_version()
'''

    if has_dependencies and dependency_check:
        version_file_content += f'''
def validate_dependencies():
    """
    Checks dependencies from manifest.json and calls {{namespace}}_version()
    for each to verify installed versions meet requirements on Talon startup.

    Prints warnings to Talon log when dependencies are missing or outdated,
    including installation/update instructions. Can be disabled by setting
    'validateDependencies': false in manifest.json.
    """
    try:
        manifest_path = Path(__file__).parent / 'manifest.json'
        with open(manifest_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        if not data.get('validateDependencies', True):
            return

        deps = data.get('dependencies', {{}})
        errors = []

        for dep, info in deps.items():
            version_action_name = f"{{info.get('namespace')}}_version"
            github_url = info.get('github', '')
            version_str = info.get('min_version') or info.get('version')
            try:
                version_action = actions
                for part in version_action_name.split('.'):
                    version_action = getattr(version_action, part)
                installed = version_action()

                if not isinstance(installed, tuple):
                    installed = tuple(int(x) for x in str(installed).split('.'))

                required = tuple(int(x) for x in version_str.split('.'))
                if installed < required:
                    installed_str = '.'.join(map(str, installed))
                    errors.append(f"  Update {{dep}} to {{version_str}}+ (currently {{installed_str}})")
                    if github_url:
                        errors.append(f"    Navigate to the {{dep}} directory and run: git pull")
                        errors.append(f"    {{github_url}}")
                    errors.append("")
            except Exception as e:
                errors.append(f"  Cannot verify {{dep}} {{version_str}}+ (missing or invalid {{version_action_name}} action)")
                if github_url:
                    errors.append(f"    Install/update from: {{github_url}}")
                errors.append(f"    {{e}}")
                errors.append("")

        if errors:
            print(f"{'='*60}")
            print(f"{{data.get('name')}}: dependency requirements not met\\n")
            for error in errors:
                print(error)
            print("  WARNING: Review code from unfamiliar sources before installing")
            print("  Note: You may need to restart Talon after updating")
            print("  To disable these warnings:")
            print(f"    Set 'validateDependencies': false in {{manifest_path}}")
            print(f"{'='*60}")
    except:
        pass

app.register("ready", validate_dependencies)
'''

    if dry_run:
        # Show diff without writing
        from diff_utils import diff_text, format_diff_output, status_no_change, status_created, DIM, RESET

        existing_content = ""
        if version_file_exists:
            with open(version_file_path, 'r', encoding='utf-8') as f:
                existing_content = f.read()

        has_changes, diff_output = diff_text(existing_content, version_file_content, "_version.py")

        if not version_file_exists:
            print(status_created("_version.py") + f" {DIM}(dry run){RESET}")
            # Show full content as diff (all + lines)
            _, new_diff = diff_text("", version_file_content, "_version.py")
            print(format_diff_output(new_diff))
        elif has_changes:
            print(f"_version.py: {DIM}(dry run){RESET}")
            print(format_diff_output(diff_output))
        else:
            print(status_no_change("_version.py"))
    else:
        # Read existing content for diff comparison
        existing_content = ""
        if version_file_exists:
            with open(version_file_path, 'r', encoding='utf-8') as f:
                existing_content = f.read()

        # Compare and show diff or "no changes"
        from diff_utils import diff_text, format_diff_output, status_no_change, status_created

        has_changes, diff_output = diff_text(existing_content, version_file_content, "_version.py")

        if not version_file_exists:
            # New file - always write
            with open(version_file_path, 'w', encoding='utf-8') as f:
                f.write(version_file_content)
            if action_name:
                add_version_action_to_manifest(manifest_path, action_name)
            print(status_created("_version.py"))
            # Show full content as diff (all + lines)
            _, new_diff = diff_text("", version_file_content, "_version.py")
            print(format_diff_output(new_diff))
        elif has_changes:
            # Existing file with changes - show diff and write
            with open(version_file_path, 'w', encoding='utf-8') as f:
                f.write(version_file_content)
            print(f"_version.py:")
            print(format_diff_output(diff_output))
        else:
            # No changes (shouldn't normally reach here due to early exit above)
            print(status_no_change("_version.py"))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python generate_version.py <directory> [<directory2> ...] [--force] [--dry-run] [--verbose]")
        print("Example: python generate_version.py ../my-package")
        print("Example: python generate_version.py ../package1 ../package2")
        sys.exit(1)

    force = '--force' in sys.argv
    dry_run = '--dry-run' in sys.argv
    verbose = '--verbose' in sys.argv or '-v' in sys.argv

    # Get alternate manifest path (for dry-run mode with mock manifest)
    alt_manifest_path = None
    skip_next = False
    package_dirs = []
    for i, arg in enumerate(sys.argv[1:], 1):
        if skip_next:
            skip_next = False
            continue
        if arg == "--manifest-path" and i + 1 < len(sys.argv):
            alt_manifest_path = sys.argv[i + 1]
            skip_next = True
        elif not arg.startswith('--'):
            package_dirs.append(arg)

    if dry_run and verbose:
        print("DRY RUN MODE - No files will be modified\n")

    for package_dir in package_dirs:
        generate_version_action(package_dir, force, dry_run, verbose, alt_manifest_path)
