import json
import os
import sys

"""
Generate a Talon action that exposes package version from manifest.json
and validates dependencies on startup.

Usage: python generate_version_action.py <package_directory>
Example: python generate_version_action.py ../my-package
"""

def get_generator_version() -> str:
    """Get the version of manifest_builder from its own manifest.json"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    manifest_path = os.path.join(script_dir, 'manifest.json')
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest = json.load(f)
            return manifest.get('version', '1.0.0')
    except:
        return '1.0.0'

def get_existing_generator_version(version_file_path: str) -> str | None:
    """Extract generator version from existing version.py file"""
    if not os.path.exists(version_file_path):
        return None

    try:
        with open(version_file_path, 'r', encoding='utf-8') as f:
            first_line = f.readline()
            # Look for: """Generated by talon-manifest-tools v1.2.0"""
            if 'talon-manifest-tools v' in first_line:
                version = first_line.split('v')[1].split('"')[0]
                return version.strip()
    except:
        pass
    return None

def generate_version_action(package_dir: str, force: bool = False) -> None:
    """Generate version action file for a package"""
    full_package_dir = os.path.abspath(package_dir)

    if not os.path.isdir(full_package_dir):
        print(f"Error: Directory not found: {full_package_dir}")
        sys.exit(1)

    # Read manifest.json
    manifest_path = os.path.join(full_package_dir, 'manifest.json')
    if not os.path.exists(manifest_path):
        print(f"Error: manifest.json not found in {full_package_dir}")
        print("Run generate_manifest.py first to generate a manifest.")
        sys.exit(1)

    with open(manifest_path, 'r', encoding='utf-8') as f:
        manifest = json.load(f)

    namespace = manifest.get('namespace', '')
    if not namespace:
        print(f"Error: No namespace found in manifest.json")
        sys.exit(1)

    # Strip 'user.' prefix if present for function name
    if namespace.startswith('user.'):
        action_name = namespace[5:]
    else:
        action_name = namespace

    package_name = manifest.get('name', os.path.basename(full_package_dir))
    generator_version = get_generator_version()
    has_dependencies = bool(manifest.get('dependencies'))
    dependency_check = manifest.get('validateDependencies', True)

    # Check if file already exists and compare versions
    version_file_path = os.path.join(full_package_dir, '_version.py')
    existing_version = get_existing_generator_version(version_file_path)

    # Force regeneration if dependency state changed
    needs_regen = False
    if os.path.exists(version_file_path):
        with open(version_file_path, 'r', encoding='utf-8') as f:
            existing_content = f.read()
            has_validation_code = 'validate_dependencies' in existing_content
            if has_dependencies != has_validation_code:
                needs_regen = True
                print(f"Regenerating _version.py (dependency state changed)")

    if not force and not needs_regen and existing_version and existing_version == generator_version:
        print(f"\n_version.py is already up to date (v{generator_version})")
        print(f"Use --force to regenerate anyway")
        sys.exit(0)
    elif force and existing_version == generator_version:
        print(f"Force regenerating _version.py (v{generator_version})")
    elif existing_version:
        print(f"Updating _version.py from v{existing_version} to v{generator_version}")

    # Generate the version action file
    description_parts = [f"- Package version checking via {action_name}_version() action"]
    if has_dependencies and dependency_check:
        description_parts.append("- Automatic dependency validation on startup")

    talon_imports = "Module, actions, app" if (has_dependencies and dependency_check) else "Module"

    version_file_content = f'''"""
DO NOT EDIT - Auto-generated file
Generated by talon-manifest-tools v{generator_version}

This file provides:
{chr(10).join(description_parts)}
"""
import json
import os
from talon import {talon_imports}

mod = Module()

@mod.action_class
class Actions:
    def {action_name}_version() -> tuple[int, int, int]:
        """Returns the package version as (major, minor, patch)"""
        manifest_path = os.path.join(os.path.dirname(__file__), 'manifest.json')
        with open(manifest_path, 'r', encoding='utf-8') as f:
            version_str = json.load(f)['version']
        return tuple(map(int, version_str.split('.')))
'''

    if has_dependencies and dependency_check:
        version_file_content += f'''
def validate_dependencies():
    try:
        with open(os.path.join(os.path.dirname(__file__), 'manifest.json'), 'r') as f:
            data = json.load(f)

        if not data.get('validateDependencies', True):
            return

        deps = data.get('dependencies', {{}})
        errors = []

        for dep, info in deps.items():
            version_action = f"{{info['namespace']}}_version"
            github_url = info.get('github', '')
            try:
                installed = getattr(actions, version_action)()
                required = tuple(int(x) for x in info['version'].split('.'))
                if installed < required:
                    installed_str = '.'.join(map(str, installed))
                    errors.append(f"  Update {{dep}} to {{info['version']}}+ (currently {{installed_str}})")
                    if github_url:
                        errors.append(f"    Navigate to the {{dep}} directory and run: git pull")
                        errors.append(f"    {{github_url}}")
            except AttributeError:
                errors.append(f"  Install {{dep}} (missing {{version_action}})")
                if github_url:
                    errors.append(f"    Clone to your talon user directory:")
                    errors.append(f"    git clone {{github_url}}")
            except Exception as e:
                errors.append(f"  {{dep}}: {{e}}")

        if errors:
            print(f"\\n{{data.get('name')}}: dependency not met")
            for error in errors:
                print(error)
            print("  WARNING: Review code from unfamiliar sources before installing")
            print("  Note: Restart Talon after updating dependencies")
            print()
    except:
        pass

app.register("ready", validate_dependencies)
'''

    # Write the version file
    with open(version_file_path, 'w', encoding='utf-8') as f:
        f.write(version_file_content)

    display_path = version_file_path.replace('\\', '/')
    print(f"\nGenerated: {display_path}")
    print(f"  Action: actions.user.{action_name}_version()")
    print(f"  Generator: v{generator_version}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python generate_version.py <directory> [--force]")
        print("Example: python generate_version.py ../my-package")
        print("  --force: Regenerate even if already up to date")
        sys.exit(1)

    package_dir = sys.argv[1]
    force = '--force' in sys.argv
    generate_version_action(package_dir, force)
